# ==============================================================================
# Snakemake workflow: Demultiplexing of Illumina sequencing data 
#                     containing unique molecular identifiers (UMIs)
#
# Author: Raphael Hablesreiter (raphael.hablesreiter@charite.de)
#         Robert Altwasser (robert.altwasser@charite.de
#
# Description:
# Snakemake implementation of IDT analysis guidlines "Demultiplexing Illumina 
# sequencing data containing unique molecular identifiers (UMIs)".
# ==============================================================================

# ==============================================================================
# Initialization of workflow
# ==============================================================================

import pandas as pd
import numpy as np
# from snakemake.utils import validate
# from snakemake.utils import min_version
# 
# min_version("5.7.1")
# 
# # configfile: "config_stroke.yaml"
# # configfile: "config/config1081.yaml"
# configfile: "config/config1162.yaml"
# # configfile: "config1156.yaml"
# validate(config, schema="schemas/config.schema.yaml")
# 
# workdir: config["general"]["work_dir"]


### Get sample ->Lane matrix
LANES=["1","2"]
barcode_file_prefix= "/home/altwassr/ablage/P1081/P1081_barcode"
library_file_prefix= "/home/altwassr/ablage/P1081/P1081_library_params"

temp_samples = pd.Series([], dtype = "str", name = "samples")
temp_lanes = pd.Series([], dtype = "str", name = "lanes")
for lane in LANES:
    print(lane)
    
    df = pd.read_csv(barcode_file_prefix + lane + ".csv", sep = '\t')
    
    temp_samples = pd.concat([temp_samples, df.iloc[:,0]])
    temp_lanes = pd.concat([temp_lanes, pd.Series(np.repeat(lane, df.iloc[:,0].size))])


samples_lanes = pd.DataFrame({"sample_names" : temp_samples,
                              "lanes": temp_lanes})
samples_lanes = samples_lanes.set_index("sample_names")



# # Get sample names from barcode file
# df = pd.read_csv(config["general"]["barcode_file"], sep = '\t', index_col = 'barcode_name')
# SAMPLES = df.index
# 
# print(SAMPLES)

def get_lane_by_sample(sample):
    return(samples_lanes.loc[sample])



rule test_lanes:
    output:
        expand("lane_{lane}/lane_{lane}.txt", lane=LANE)
    params:
        lane_dir=expand("lane_{lane}", lane=LANE)
    shell:
        """
        mkdir -p {params.lane_dir}
        touch {output}
        """
# # ==============================================================================
# # Include rules
# # ==============================================================================
# 
# if config["general"]["demux"]:
#     include: "rules/demux.smk"
# 
# include: "rules/qc.smk"
# include: "rules/tools.smk"
# 
# # ==============================================================================
# # Results
# # ==============================================================================
# 
rule all:
    input:
        expand("lane_{lane}/lane_{lane}.txt", lane=LANE)
        # "qc/multiqc_reads.html",
        # "qc/multiqc_alignments.html"
