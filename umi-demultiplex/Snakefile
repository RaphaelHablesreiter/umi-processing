# ==============================================================================
# Snakemake workflow: Demultiplexing of Illumina sequencing data 
#                     containing unique molecular identifiers (UMIs)
#
# Author: Raphael Hablesreiter (raphael.hablesreiter@charite.de)
#         Robert Altwasser (robert.altwasser@charite.de
#
# Description:
# Snakemake implementation of IDT analysis guidlines "Demultiplexing Illumina 
# sequencing data containing unique molecular identifiers (UMIs)".
# ==============================================================================

# ==============================================================================
# Initialization of workflow
# ==============================================================================

import pandas as pd
import numpy as np
from snakemake.utils import validate
from snakemake.utils import min_version

min_version("5.7.1")

# configfile: "config_stroke.yaml"
configfile: "config/config1081.yaml"
# configfile: "config/config1162.yaml"
# configfile: "config1156.yaml"
validate(config, schema="schemas/config.schema.yaml")

workdir: config["general"]["work_dir"]

### Get sample ->Lane matrix
# LANES=["1","2"]
# SAMPLES=["A","B"]
# barcode_file_prefix= "/home/altwassr/ablage/P1081/P1081_barcode"
# library_file_prefix= "/home/altwassr/ablage/P1081/P1081_library_params"

# df = pd.read_csv(config["general"]["barcode_file"], sep = '\t', index_col = 'barcode_name')
# SAMPLES = df.index

LANES=config["illumina"]["lane"]:
print(LANES)

# Get sample names and lanes from barcode files
temp_samples = pd.Series([], dtype = "str", name = "samples")
temp_lanes = pd.Series([], dtype = "str", name = "lanes")
for lane in LANES:
    df = pd.read_csv(barcode_file_prefix + lane + ".csv", sep = '\t')
    
    temp_samples = pd.concat([temp_samples, df.iloc[:,0]])
    temp_lanes = pd.concat([temp_lanes, pd.Series(np.repeat(lane, df.iloc[:,0].size))])


### Dict mapping samples to lanes
samples_lanes = dict(zip(temp_samples, temp_lanes))
SAMPLES = temp_samples

print(SAMPLES)
# # Get sample names from barcode file
# df = pd.read_csv(config["general"]["barcode_file"], sep = '\t', index_col = 'barcode_name')
# SAMPLES = df.index
# 
# print(SAMPLES)


rule all:
    input:
        # "unmapped/AML-111.unmapped.bam"
        "unmapped/AML-385.unmapped.bam",
        "unmapped/AML-380.unmapped.bam",
        "unmapped/AML-381.unmapped.bam"
        # "fastq/sample_AML-385.fastq"
        #expand("lane_{lane}/{sample}_lane_{lane}.txt", sample=SAMPLES, lane=LANES)
        # "qc/multiqc_reads.html",
        # "qc/multiqc_alignments.html"

# ==============================================================================
# Include rules
# ==============================================================================

if config["general"]["demux"]:
    include: "rules/demux.smk"

include: "rules/qc.smk"
include: "rules/tools.smk"

# ==============================================================================
# Results
# ==============================================================================

#### Delete:
#
# rule demux:
#     input:
#         get_barcode_file_for_sample
#     output:
#         "fastq/sample_{sample}.fastq"
#     shell:
#         """
#         mkdir -p fastq
#         touch {output}
#         """
# 
# rule test_barcodes:
#     input:
#         "starter.txt"
#     output:
#         "metrices/barcode_metrices{lane}.csv"
#     shell:
#         """
#         mkdir -p metrices
#         touch {output}
#         """
#
# ### Method to return the lane for sample name
# ### REQUIRES: samples_lanes
# def get_lane_for_sample(wildcards):
#     return samples_lanes[wildcards.sample]
# 
# ### Method to return the name of 'barcode_metrices' file for sample name
# ### REQUIRES: samples_lanes
# def get_barcode_metric_for_sample(wildcards):
#     return "metrices/barcode_metrices" + samples_lanes[wildcards.sample] + ".csv"
# 
# ### Method to return the name of 'library_file' file for sample name
# ### REQUIRES: samples_lanes
# def get_library_file_for_sample(wildcards):
#     return library_file_prefix + samples_lanes[wildcards.sample] + ".csv"
# 
# # ### Method to return the name of 'barcode_file' file for sample name
# # ### REQUIRES: samples_lanes
# # def get_barcode_file_for_sample(wildcards):
# #     return barcode_file_prefix + samples_lanes[wildcards.sample] + ".csv"
# 
# rule extract_barcodes:
#     input:
#         bfile=barcode_file_prefix + "{lane}.csv"
#     output:
#         "metrices/barcode_metrices{lane}.csv"
#     shell:
#         r"""
#         mkdir -p metrices
#         cp {input.bfile} metrices/{lane}.csv
#         touch {output}
#         """
# 
# 
# rule basecalls_to_sam:
#     input:
#         metrices=get_barcode_metric_for_sample,
#         lparams=get_library_file_for_sample
#     output:
#         "unmapped/{sample}.unmapped.bam"
#     params:
#         lane=get_lane_for_sample
#     shell:
#         """
#         cp {input.lparams} unmapped/{lane}.csv
#         touch {output}
#         """
